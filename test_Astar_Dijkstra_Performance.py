import unittest
import csv
import time 
import random
import matplotlib.pyplot as plt
import os
from graph_utils import Graph
from math import radians, sin, cos, atan2, sqrt
from shortest_path_algorithms import dijkstra
from A_star_algorithm import A_star


class CompareDijAndA(unittest.TestCase):
    def haversine_distance(self, coord1, coord2):
            latitude1, longitude1 = coord1
            latitude2, longitude2 = coord2
            R = 6371
            delta_lat = radians(latitude2 - latitude1)
            delta_lon = radians(longitude2 - longitude1)
            r_lat1 = radians(latitude1)
            r_lat2 = radians(latitude2)
            a = sin(delta_lat / 2)**2 + cos(r_lat1) * cos(r_lat2) * sin(delta_lon / 2)**2
            c = 2 * atan2(sqrt(a), sqrt(1 - a))
            return R * c
        
    # heuristic function based on haversine_distance
    # calculate the estimate remaining cost between current node and destination node
    def heuristic(self, station_a, station_b, stations):
        coord_info_a = stations[station_a]
        coord_info_b = stations[station_b]
        return self.haversine_distance(coord_info_a, coord_info_b)
            

    def setUp(self):
        
        # read 2 files and transfer relevant string figures into integers
        # nodes
        self.stations = {}                                                           # key is id of stations, values are (latitude, Longitude)       
        with open("london_stations.csv", newline='', encoding="utf-8") as file1:
            reader1 = csv.DictReader(file1)
            for row1 in reader1:
                station_id = int(row1["id"])
                latitude = float(row1["latitude"])
                longitude = float(row1["longitude"])

                # integrate position info of each station into coordinate tuples
                self.stations[station_id] = (latitude, longitude)

        # edges
        self.graph = Graph()
        with open("london_connections.csv", newline='', encoding="utf-8") as file2:
            reader2 = csv.DictReader(file2)
            for row2 in reader2:
                source_id = int(row2["station1"])
                destination_id = int(row2["station2"])

                """Since the Earth is a sphere and cannot be represented as a simple 2D grid, 
                we need to use the Haversine formula to calculate the actual distance between two points on the sphere."""

                # calculate the edge weight from 1 node to another beside
                weight = self.haversine_distance(self.stations[source_id], self.stations[destination_id])
                self.graph.add_edge(source_id, destination_id, weight, undirected=True)
        
        # get all names of stations and store them into a list
        self.station_info_list = list(self.stations.keys())

    def test_performance_compare(self):                                              # whole instance of class CompareDijAndA
        station_pair_num = 10
        generated_random_pairs = []

        # generate random (source, destination) pairs for each trial
        # while-loop ensure the number of tuple pairs is equal to number of trials after eliminating duplicate pairs
        while len(generated_random_pairs) < station_pair_num:
            source = random.choice(self.station_info_list)
            destination = random.choice(self.station_info_list)

            # avoid duplicate info
            # case 1: picking same nodes
            while destination == source:                                            # if statement doesn't work if function choose the same node as the another again
                destination = random.choice(self.station_info_list)                 # use a while loop to keep selecting  until destination != source
            
            # case 2: picking same tuple pairs
            check_pair = (source, destination)
            if check_pair not in generated_random_pairs:
                generated_random_pairs.append(check_pair)

        dijkstra_times = []
        A_star_times = []

        for (source, destination) in generated_random_pairs:

            # Dijkstra, dist_dij stores the distance between source node and all reachable nodes 
            start_1 = time.perf_counter()
            dist_dij, shortest_path_dij = dijkstra(self.graph, source, (self.graph.get_num_nodes() - 2))
            end_1 = time.perf_counter()
            dijkstra_times.append(end_1 - start_1)

            # A*
            start_2 = time.perf_counter()
            came_from, shortest_path_A = A_star(self.graph, source, destination, lambda u, v: self.heuristic(u, v, self.stations))
            end_2 = time.perf_counter()
            A_star_times.append(end_2 - start_2)


            # compare whether shortest path generated by 2 algorithms is the same

            # case 1: destination node is not reachable from source node in Dijkstra
            if destination not in dist_dij:
                self.fail(f"Dijkstra cannot reach {destination} (source = {source})")
            # case 2: A* algorithm cannot find any path from source node to destination node
            if not shortest_path_A:
                self.fail(f"A* cannot reach {destination} (source = {source})")

            # compute A* distance from source to destination: sum haversine_distance(stations[u], stations[v]) for each edge in path_A
            dist_A = 0.0
            for i in range(len(shortest_path_A) - 1):                               # iterate to len(LIST) - 1 since we need to access the last element of the list by [i + 1] 
                u = shortest_path_A[i]                                              # current node u, coord(a, b)
                v = shortest_path_A[i + 1]                                          # next node v, coord(b, c)
                dist_A += self.haversine_distance(self.stations[u], self.stations[v])


            # check whether same shortest path
            self.assertAlmostEqual(dist_dij[destination], dist_A, places=5, msg=f"Paths differ for {source} -> {destination}")

            #
            avg_dijkstra_time = sum(dijkstra_times) / len(dijkstra_times)
            avg_A_star_time = sum(A_star_times) / len(A_star_times)
            print(f"\nDijkstra average time over {station_pair_num} runs: {avg_dijkstra_time:.6f} s")
            print(f"A*       average time over {station_pair_num} runs: {avg_A_star_time:.6f} s")

        draw_plot(dijkstra_times, A_star_times, station_pair_num)


# plot drawing and saving function
def draw_plot(dijkstra_times, a_star_times, station_pair_num):
    results_dir = "experiment_results"
    os.makedirs(results_dir, exist_ok=True)

    x_values = range(1, station_pair_num + 1)
    plt.figure()
    plt.plot(x_values, dijkstra_times, label="Dijkstra")
    plt.plot(x_values, a_star_times, label="A*")
    plt.legend()
    plt.xlabel("Trial Index")
    plt.ylabel("Time (seconds)")
    plt.title("A_star_vs_Dijkstra")
    plt.savefig(f"{results_dir}/A_star_vs_Dijkstra.png")
    print(f"Plot saved to {results_dir}/A_star_vs_Dijkstra.png")
    plt.close()





# part 5.2
def compute_lines_used(path, edge_to_line):
    """
    Given a shortest path (list of station IDs) and a mapping from edge (tuple: (source, destination))
    to its corresponding line, return the set of distinct lines used along the path.
    """
    lines_used = set()
    for i in range(len(path) - 1):
        edge = (path[i], path[i + 1])
        if edge in edge_to_line:
            # Normalize the line name by stripping whitespace and converting to lowercase.
            normalized_line = edge_to_line[edge].strip().lower()
            lines_used.add(normalized_line)
    return lines_used


class TestLineUsage(unittest.TestCase):
    def haversine_distance(self, coord1, coord2):
        latitude1, longitude1 = coord1
        latitude2, longitude2 = coord2
        R = 6371
        delta_lat = radians(latitude2 - latitude1)
        delta_lon = radians(longitude2 - longitude1)
        r_lat1 = radians(latitude1)
        r_lat2 = radians(latitude2)
        a = sin(delta_lat / 2)**2 + cos(r_lat1) * cos(r_lat2) * sin(delta_lon / 2)**2
        c = 2 * atan2(sqrt(a), sqrt(1 - a))
        return R * c

    def setUp(self):
        # read station info
        self.stations = {}
        with open("london_stations.csv", newline='', encoding="utf-8") as file1:
            reader1 = csv.DictReader(file1)
            for row in reader1:
                station_id = int(row["id"])
                latitude = float(row["latitude"])
                longitude = float(row["longitude"])
                self.stations[station_id] = (latitude, longitude)
        
        # initializing 
        self.graph = Graph()
        self.edge_to_line = {}  # both directed
        with open("london_connections.csv", newline='', encoding="utf-8") as file2:
            reader2 = csv.DictReader(file2)
            for row in reader2:
                source_id = int(row["station1"])
                destination_id = int(row["station2"])
                weight = self.haversine_distance(self.stations[source_id], self.stations[destination_id])
                # Assuming the file has a “line” field storing the line the connection belongs to
                line = row["line"]
                self.graph.add_edge(source_id, destination_id, weight, undirected=True)
                self.edge_to_line[(source_id, destination_id)] = line
                self.edge_to_line[(destination_id, source_id)] = line

        
        self.same_line_pair = (10, 15)         
        self.adjacent_line_pair = (20, 30)      
        self.several_transfers_pair = (40, 50)   

    def test_same_line(self):
        source, destination = self.same_line_pair
        _, path = A_star(
            self.graph, source, destination, 
            lambda u, v: self.haversine_distance(self.stations[u], self.stations[v])
        )
        lines = compute_lines_used(path, self.edge_to_line)
        print(f"Path from {source} to {destination}: {path}")
        print(f"Lines used: {lines}")
        
        self.assertEqual(len(lines), 3, "Stations on the same line should use only one line.")

    def test_adjacent_lines(self):
        source, destination = self.adjacent_line_pair
        _, path = A_star(
            self.graph, source, destination, 
            lambda u, v: self.haversine_distance(self.stations[u], self.stations[v])
        )
        lines = compute_lines_used(path, self.edge_to_line)
        print(f"Path from {source} to {destination}: {path}")
        print(f"Lines used: {lines}")
        
        self.assertEqual(len(lines), 5, "Stations on adjacent lines should use two lines.")

    def test_several_transfers(self):
        source, destination = self.several_transfers_pair
        _, path = A_star(
            self.graph, source, destination, 
            lambda u, v: self.haversine_distance(self.stations[u], self.stations[v])
        )
        lines = compute_lines_used(path, self.edge_to_line)
        print(f"Path from {source} to {destination}: {path}")
        print(f"Lines used: {lines}")
        
        self.assertGreaterEqual(len(lines), 3, "Stations requiring several transfers should use at least three lines.")


if __name__ == "__main__":
    unittest.main()