import unittest
import csv
import time 
import random
from graph_utils import Graph
from math import radians, sin, cos, atan2, sqrt
from shortest_path_algorithms import dijkstra
from A_star_algorithm import A_star


class CompareDijAndA(unittest.TestCase):
    def haversine_distance(self, coord1, coord2):
            latitude1, longitude1 = coord1
            latitude2, longitude2 = coord2
            R = 6371
            delta_lat = radians(latitude2 - latitude1)
            delta_lon = radians(longitude2 - longitude1)
            r_lat1 = radians(latitude1)
            r_lat2 = radians(latitude2)
            a = sin(delta_lat / 2)**2 + cos(r_lat1) * cos(r_lat2) * sin(delta_lon / 2)**2
            c = 2 * atan2(sqrt(a), sqrt(1 - a))
            return R * c
        
    # heuristic function based on haversine_distance
    # calculate the estimate remaining cost between current node and destination node
    def heuristic(self, station_a, station_b, stations):
        coord_info_a = stations[station_a]
        coord_info_b = stations[station_b]
        return self.haversine_distance(coord_info_a, coord_info_b)
            

    def setUp(self):

        # nodes
        self.stations = {}                                                           # key is id of stations, values are (latitude, Longitude)       
        with open("london_stations.csv", newline='', encoding="utf-8") as file1:
            reader1 = csv.DictReader(file1)
            for row1 in reader1:
                station_id = row1["id"]
                latitude = float(row1["latitude"])
                longitude = float(row1["longitude"])

                # integrate position info of each station into coordinate tuples
                self.stations[station_id] = (latitude, longitude)

        # edges
        self.graph = Graph()
        with open("london_connections.csv", newline='', encoding="utf-8") as file2:
            reader2 = csv.DictReader(file2)
            for row2 in reader2:
                source_id = row2["station1"]
                destination_id = row2["station2"]

                """Since the Earth is a sphere and cannot be represented as a simple 2D grid, 
                we need to use the Haversine formula to calculate the actual distance between two points on the sphere."""

                # calculate the edge weight from 1 node to another beside
                weight = self.haversine_distance(self.stations[source_id], self.stations[destination_id])
                self.graph.add_edge(source_id, destination_id, weight)
        
        # get all names of stations and store them into a list
        self.station_info_list = list(self.stations.keys())

    def test_performance_compare(self):                                              # whole instance of class CompareDijAndA
        station_pair_num = 10
        generated_random_pairs = []
        n = len(self.station_info_list)

        # generate random (source, destination) pairs for each trial
        # while-loop ensure the number of tuple pairs is equal to number of trials after eliminating duplicate pairs
        while len(generated_random_pairs) < station_pair_num:
            source = random.choice(self.station_info_list)
            destination = random.choice(self.station_info_list)

            # avoid duplicate info
            # case 1: picking same nodes
            while destination == source:                                        # if statement doesn't work if function choose the same node as the another again
                destination = random.choice(self.station_info_list)             # use a while loop to keep selecting  until destination != source
            
            # case 2: picking same tuple pairs
            check_pair = (source, destination)
            if check_pair not in generated_random_pairs:
                generated_random_pairs.append(check_pair)

        dijkstra_times = []
        A_star_times = []

        for (source, destination) in generated_random_pairs:

            # Dijkstra
            start_1 = time.perf_counter()
            dist_dij, path_dij = dijkstra(self.graph, source, destination)
            end_1 = time.perf_counter()
            dijkstra_times.append(end_1 - start_1)

            # A*
            start_2 = time.perf_counter()
            dist_A, path_A = A_star(self.graph, source, destination, lambda u, v: self.heuristic(u, v, self.stations))
            end_2 = time.perf_counter()
            A_star_times.append(end_2 - start_2)


            # compare whether 2 paths generated by 2 algorithms are similarly same
            # if these 2 algrithms use the same graph in each trial, the solution path is supposed to be similarly same
            self.assertAlmostEqual(dist_dij, dist_A, places=5, msg=f"Paths differ for {source} -> {destination}")

            avg_dijkstra_time = sum(dijkstra_times) / len(dijkstra_times)
            avg_A_star_time = sum(A_star_times) / len(A_star_times)
            print(f"\nDijkstra average time over {station_pair_num} runs: {avg_dijkstra_time:.6f} s")
            print(f"A*       average time over {station_pair_num} runs: {avg_A_star_time:.6f} s")
        

if __name__ == "__main__":
    unittest.main()
